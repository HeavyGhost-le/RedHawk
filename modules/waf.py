"""
WAF (Web Application Firewall) Detection Module
Identifies the presence and type of WAF
"""

import requests
from typing import Dict, List
import warnings

# Suppress SSL warnings (expected for security scanning)
warnings.filterwarnings('ignore', message='Unverified HTTPS request')
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class Scanner:
    def __init__(self):
        self.name = "WAF Scanner"
        self.description = "Web Application Firewall detection"
        
        # WAF signatures
        self.waf_signatures = {
            'cloudflare': {
                'headers': ['cf-ray', 'cf-cache-status'],
                'cookies': ['__cfduid'],
                'content': ['cloudflare']
            },
            'akamai': {
                'headers': ['x-akamai'],
                'cookies': ['ak_bmsc'],
                'content': []
            },
            'aws-waf': {
                'headers': ['x-amzn-requestid', 'x-amz-cf-id'],
                'cookies': [],
                'content': ['access denied']
            },
            'imperva': {
                'headers': ['x-iinfo'],
                'cookies': ['incap_ses', 'visid_incap'],
                'content': ['incapsula']
            },
            'f5-big-ip': {
                'headers': [],
                'cookies': ['BIGipServer', 'TS'],
                'content': []
            },
            'sucuri': {
                'headers': ['x-sucuri-id', 'x-sucuri-cache'],
                'cookies': [],
                'content': ['sucuri']
            },
            'wordfence': {
                'headers': [],
                'cookies': ['wfvt_'],
                'content': ['wordfence', 'generated by wordfence']
            },
            'barracuda': {
                'headers': ['x-barracuda'],
                'cookies': [],
                'content': ['barracuda']
            },
            'fortinet': {
                'headers': [],
                'cookies': [],
                'content': ['fortinet', 'fortigate']
            },
            'modsecurity': {
                'headers': [],
                'cookies': [],
                'content': ['mod_security', 'modsecurity']
            }
        }
    
    def scan(self, target: str, config: Dict) -> Dict:
        """Main scan function"""
        results = {
            'target': target,
            'waf_detected': False,
            'waf_type': None,
            'confidence': 0,
            'detection_methods': [],
            'recommendations': []
        }
        
        try:
            # Try HTTPS first
            try:
                url = f"https://{target}"
                response = requests.get(url, timeout=10, allow_redirects=True, verify=False)
            except:
                url = f"http://{target}"
                response = requests.get(url, timeout=10, allow_redirects=True)
            
            # Detect WAF
            detected_wafs = []
            
            for waf_name, signatures in self.waf_signatures.items():
                confidence = 0
                methods = []
                
                # Check headers
                for header in signatures['headers']:
                    if any(header.lower() in h.lower() for h in response.headers):
                        confidence += 40
                        methods.append(f"Header: {header}")
                
                # Check cookies
                for cookie in signatures['cookies']:
                    if any(cookie.lower() in c.lower() for c in response.cookies):
                        confidence += 30
                        methods.append(f"Cookie: {cookie}")
                
                # Check content
                content = response.text.lower()
                for keyword in signatures['content']:
                    if keyword.lower() in content:
                        confidence += 20
                        methods.append(f"Content: {keyword}")
                
                if confidence > 0:
                    detected_wafs.append({
                        'name': waf_name,
                        'confidence': min(confidence, 100),
                        'methods': methods
                    })
            
            # Get the most likely WAF
            if detected_wafs:
                detected_wafs.sort(key=lambda x: x['confidence'], reverse=True)
                best_match = detected_wafs[0]
                
                results['waf_detected'] = True
                results['waf_type'] = best_match['name']
                results['confidence'] = best_match['confidence']
                results['detection_methods'] = best_match['methods']
                results['all_detections'] = detected_wafs
            
            # Add recommendations
            if results['waf_detected']:
                results['recommendations'] = self.get_waf_recommendations(results['waf_type'])
            
            results['status'] = 'success'
        except Exception as e:
            results['status'] = 'error'
            results['error'] = str(e)
        
        return results
    
    def get_waf_recommendations(self, waf_type: str) -> List[str]:
        """Get pentesting recommendations for detected WAF"""
        recommendations = {
            'cloudflare': [
                'Consider rate limiting and IP blocking',
                'Test for origin server IP disclosure',
                'Check for subdomain bypasses',
                'Test for HTTP/2 vulnerabilities'
            ],
            'akamai': [
                'Test for cache poisoning',
                'Check origin server exposure',
                'Test rate limiting thresholds'
            ],
            'aws-waf': [
                'Test custom rule bypasses',
                'Check for misconfigurations',
                'Test regional endpoint access'
            ],
            'imperva': [
                'Test for encoding bypasses',
                'Check for client classification issues',
                'Test JavaScript challenge bypasses'
            ],
            'f5-big-ip': [
                'Check for known CVEs',
                'Test iRule misconfigurations',
                'Check for cookie manipulation'
            ],
            'default': [
                'Test for common WAF bypasses',
                'Check encoding and obfuscation',
                'Test timing-based attacks',
                'Look for origin server exposure'
            ]
        }
        
        return recommendations.get(waf_type, recommendations['default'])